import sys
_module = sys.modules[__name__]
del sys
cifar10 = _module
imagenet = _module
inaturalist2018 = _module
places205 = _module
default_runtime = _module
resnet50 = _module
resnet50_multihead = _module
knn_imagenet = _module
svm_voc07 = _module
tsne_imagenet = _module
coco_instance = _module
voc0712 = _module
faster_rcnn_r50_c4 = _module
mask_rcnn_r50_c4 = _module
mask_rcnn_r50_fpn = _module
schedule_1x = _module
schedule_24k = _module
schedule_2x = _module
mask_rcnn_r50_c4_mstrain_1x_coco = _module
mask_rcnn_r50_c4_mstrain_2x_coco = _module
mask_rcnn_r50_fpn_mstrain_1x_coco = _module
mask_rcnn_r50_fpn_mstrain_2x_coco = _module
faster_rcnn_r50_c4_mstrain_24k_voc0712 = _module
cityscapes = _module
cityscapes_769x769 = _module
pascal_voc12 = _module
pascal_voc12_aug = _module
schedule_20k = _module
schedule_40k = _module
imagenet_byol = _module
imagenet_cae = _module
imagenet_deepcluster = _module
imagenet_mae = _module
imagenet_maskfeat = _module
imagenet_mocov1 = _module
imagenet_mocov2 = _module
imagenet_mocov3 = _module
imagenet_npid = _module
imagenet_odc = _module
imagenet_simclr = _module
imagenet_simmim = _module
barlowtwins = _module
byol = _module
cae = _module
deepcluster = _module
densecl = _module
mocov1 = _module
mocov2 = _module
npid = _module
odc = _module
simclr = _module
simsiam = _module
swav = _module
conf = _module
mmselfsup = _module
apis = _module
inference = _module
train = _module
core = _module
hooks = _module
cosine_annealing_hook = _module
deepcluster_hook = _module
densecl_hook = _module
momentum_update_hook = _module
odc_hook = _module
optimizer_hook = _module
simsiam_hook = _module
swav_hook = _module
optimizer = _module
builder = _module
constructor = _module
optimizers = _module
transformer_finetune_constructor = _module
datasets = _module
base = _module
builder = _module
data_sources = _module
cifar = _module
image_list = _module
imagenet_21k = _module
dataset_wrappers = _module
deepcluster = _module
multi_view = _module
pipelines = _module
transforms = _module
relative_loc = _module
rotation_pred = _module
samplers = _module
distributed_sampler = _module
group_sampler = _module
single_view = _module
utils = _module
models = _module
algorithms = _module
barlowtwins = _module
base = _module
byol = _module
cae = _module
classification = _module
deepcluster = _module
densecl = _module
mae = _module
maskfeat = _module
mmcls_classifier_wrapper = _module
moco = _module
mocov3 = _module
npid = _module
odc = _module
relative_loc = _module
rotation_pred = _module
simclr = _module
simmim = _module
simsiam = _module
swav = _module
backbones = _module
cae_vit = _module
mae_vit = _module
maskfeat_vit = _module
mim_cls_vit = _module
resnet = _module
resnext = _module
simmim_swin = _module
vision_transformer = _module
heads = _module
cae_head = _module
cls_head = _module
contrastive_head = _module
latent_pred_head = _module
mae_head = _module
maskfeat_head = _module
mocov3_head = _module
multi_cls_head = _module
simmim_head = _module
swav_head = _module
memories = _module
odc_memory = _module
simple_memory = _module
necks = _module
avgpool2d_neck = _module
cae_neck = _module
densecl_neck = _module
linear_neck = _module
mae_neck = _module
mocov2_neck = _module
nonlinear_neck = _module
odc_neck = _module
relative_loc_neck = _module
simmim_neck = _module
swav_neck = _module
accuracy = _module
dall_e = _module
extract_process = _module
gather_layer = _module
hog_layer = _module
knn_classifier = _module
multi_pooling = _module
multi_prototypes = _module
position_embedding = _module
res_layer_extra_norm = _module
sobel = _module
transformer_blocks = _module
alias_multinomial = _module
batch_shuffle = _module
clustering = _module
collect = _module
collect_env = _module
dist_utils = _module
distributed_sinkhorn = _module
extractor = _module
gather = _module
logger = _module
misc = _module
setup_env = _module
test_helper = _module
version = _module
setup = _module
test_inference = _module
test_train = _module
test_common = _module
test_image_list = _module
test_imagenet = _module
test_builder = _module
test_dataset_wrapper = _module
test_deepcluster_dataset = _module
test_multiview_dataset = _module
test_relative_loc_dataset = _module
test_rotation_pred_dataset = _module
test_singleview_dataset = _module
test_pipeline = _module
test_utils = _module
test_accuracy = _module
test_barlowtwins = _module
test_byol = _module
test_cae = _module
test_classification = _module
test_deepcluster = _module
test_densecl = _module
test_mae = _module
test_maskfeat = _module
test_mmcls_classifier_wrapper = _module
test_moco = _module
test_mocov3 = _module
test_npid = _module
test_odc = _module
test_relative_loc = _module
test_rotation_pred = _module
test_simclr = _module
test_simmim = _module
test_simsiam = _module
test_swav = _module
test_mae_pretrain_vit = _module
test_maskfeat_pretrain_vit = _module
test_mim_cls_vit = _module
test_resnet = _module
test_resnext = _module
test_vision_transformer = _module
test_heads = _module
test_avgpool_neck = _module
test_densecl_neck = _module
test_linear_neck = _module
test_mae_neck = _module
test_mocov2_neck = _module
test_nonlinear_neck = _module
test_odc_neck = _module
test_relative_loc_neck = _module
test_swav_neck = _module
test_dalle = _module
test_knn_classifier = _module
test_multi_pooling = _module
test_multi_prototypes = _module
test_sobel = _module
test_extract_process = _module
test_extractor = _module
test_byol_hook = _module
test_cosine_annealing_hook = _module
test_deepcluster_hook = _module
test_densecl_hook = _module
test_optimizer_hook = _module
test_simsiam_hook = _module
test_swav_hook = _module
test_optimizer = _module
test_alias_multinomial = _module
test_clustering = _module
test_misc = _module
test_setup_env = _module
test_test_helper = _module
test_version_utils = _module
analyze_logs = _module
count_parameters = _module
visualize_tsne = _module
test_knn = _module
extract = _module
aggregate_low_shot_svm_stats = _module
svm_helper = _module
test_svm = _module
test_svm_low_shot = _module
train_svm_kfold = _module
train_svm_kfold_parallel = _module
train_svm_low_shot = _module
train_svm_low_shot_parallel = _module
train_net = _module
convert_imagenet_subsets = _module
convert_inaturalist = _module
create_voc_data_files = _module
create_voc_low_shot_challenge_samples = _module
mae_visualization = _module
print_config = _module
extract_backbone_weights = _module
publish_model = _module
test = _module
train = _module

from _paritybench_helpers import _mock_config, patch_functional
from unittest.mock import mock_open, MagicMock
from torch.autograd import Function
from torch.nn import Module
import abc, collections, copy, enum, functools, inspect, itertools, logging, math, matplotlib, numbers, numpy, pandas, queue, random, re, scipy, sklearn, string, tensorflow, time, torch, torchaudio, torchtext, torchvision, types, typing, uuid, warnings
import numpy as np
from torch import Tensor
patch_functional()
open = mock_open()
yaml = logging = sys = argparse = MagicMock()
ArgumentParser = argparse.ArgumentParser
_global_config = args = argv = cfg = config = params = _mock_config()
argparse.ArgumentParser.return_value.parse_args.return_value = _global_config
yaml.load.return_value = _global_config
sys.argv = _global_config
__version__ = '1.0.0'
xrange = range
wraps = functools.wraps


from typing import Optional


from typing import Tuple


from typing import Union


import torch


from torch import nn


from torchvision.transforms import Compose


import random


import numpy as np


import torch.distributed as dist


import copy


import re


from torch.optim import *


from torch.optim.optimizer import Optimizer


from torch.optim.optimizer import required


import warnings


from abc import ABCMeta


from abc import abstractmethod


from torch.utils.data import Dataset


from functools import partial


from torch.utils.data import DataLoader


from torch.utils.data.dataset import ConcatDataset as _ConcatDataset


import inspect


import math


from typing import Sequence


import torchvision.transforms.functional as F


from torchvision import transforms as _transforms


import torchvision.transforms.functional as TF


from torchvision.transforms import RandomCrop


from torch.utils.data import DistributedSampler as _DistributedSampler


from torch.utils.data import Sampler


from typing import List


from collections import OrderedDict


import torch.nn as nn


from torchvision.transforms import Normalize


from typing import Dict


from functools import reduce


from torch.nn.modules.batchnorm import _BatchNorm


from torch.nn import functional as F


from sklearn.cluster import KMeans


import torch.nn.functional as F


import time


from scipy.sparse import csr_matrix


import torch.multiprocessing as mp


import logging


import matplotlib.pyplot as plt


from sklearn.manifold import TSNE


class HOGLayerC(nn.Module):
    """Generate hog feature for each batch images. This module is used in
    Maskfeat to generate hog feature. This code is borrowed from.

    <https://github.com/facebookresearch/SlowFast/blob/main/slowfast/models/operators.py>
    Args:
        nbins (int): Number of bin. Defaults to 9.
        pool (float): Number of cell. Defaults to 8.
        gaussian_window (int): Size of gaussian kernel. Defaults to 16.
    """

    def __init__(self, nbins: int=9, pool: int=8, gaussian_window: int=16) ->None:
        super().__init__()
        self.nbins = nbins
        self.pool = pool
        self.pi = math.pi
        weight_x = torch.FloatTensor([[1, 0, -1], [2, 0, -2], [1, 0, -1]])
        weight_x = weight_x.view(1, 1, 3, 3).repeat(3, 1, 1, 1)
        weight_y = weight_x.transpose(2, 3)
        self.register_buffer('weight_x', weight_x)
        self.register_buffer('weight_y', weight_y)
        self.gaussian_window = gaussian_window
        if gaussian_window:
            gkern = self.get_gkern(gaussian_window, gaussian_window // 2)
            self.register_buffer('gkern', gkern)

    def get_gkern(self, kernlen: int, std: int) ->torch.Tensor:
        """Returns a 2D Gaussian kernel array."""

        def _gaussian_fn(kernlen: int, std: int) ->torch.Tensor:
            n = torch.arange(0, kernlen).float()
            n -= n.mean()
            n /= std
            w = torch.exp(-0.5 * n ** 2)
            return w
        gkern1d = _gaussian_fn(kernlen, std)
        gkern2d = gkern1d[:, None] * gkern1d[None, :]
        return gkern2d / gkern2d.sum()

    def _reshape(self, hog_feat: torch.Tensor) ->torch.Tensor:
        hog_feat = hog_feat.flatten(1, 2)
        unfold_size = hog_feat.shape[-1] // 14
        hog_feat = hog_feat.permute(0, 2, 3, 1).unfold(1, unfold_size, unfold_size).unfold(2, unfold_size, unfold_size).flatten(1, 2).flatten(2)
        return hog_feat

    @torch.no_grad()
    def forward(self, x: torch.Tensor) ->torch.Tensor:
        """Generate hog feature for each batch images.

        Args:
            x (torch.Tensor): Input images of shape (N, 3, H, W).
        Returns:
            torch.Tensor: Hog features.
        """
        x = F.pad(x, pad=(1, 1, 1, 1), mode='reflect')
        gx_rgb = F.conv2d(x, self.weight_x, bias=None, stride=1, padding=0, groups=3)
        gy_rgb = F.conv2d(x, self.weight_y, bias=None, stride=1, padding=0, groups=3)
        norm_rgb = torch.stack([gx_rgb, gy_rgb], dim=-1).norm(dim=-1)
        phase = torch.atan2(gx_rgb, gy_rgb)
        phase = phase / self.pi * self.nbins
        b, c, h, w = norm_rgb.shape
        out = torch.zeros((b, c, self.nbins, h, w), dtype=torch.float, device=x.device)
        phase = phase.view(b, c, 1, h, w)
        norm_rgb = norm_rgb.view(b, c, 1, h, w)
        if self.gaussian_window:
            if h != self.gaussian_window:
                assert h % self.gaussian_window == 0, 'h {} gw {}'.format(h, self.gaussian_window)
                repeat_rate = h // self.gaussian_window
                temp_gkern = self.gkern.repeat([repeat_rate, repeat_rate])
            else:
                temp_gkern = self.gkern
            norm_rgb *= temp_gkern
        out.scatter_add_(2, phase.floor().long() % self.nbins, norm_rgb)
        out = out.unfold(3, self.pool, self.pool)
        out = out.unfold(4, self.pool, self.pool)
        out = out.sum(dim=[-1, -2])
        out = F.normalize(out, p=2, dim=2)
        return self._reshape(out)


class ExampleModel(nn.Module):

    def __init__(self):
        super(ExampleModel, self).__init__()
        self.test_cfg = None
        self.conv = nn.Conv2d(3, 3, 3)

    def forward(self, img, mode='test', **kwargs):
        return dict(img=img)

    def train_step(self, data_batch, optimizer):
        loss = self.forward(**data_batch)
        return dict(loss=loss)


import torch
from torch.nn import MSELoss, ReLU
from _paritybench_helpers import _mock_config, _mock_layer, _paritybench_base, _fails_compile


TESTCASES = [
    # (nn.Module, init_args, forward_args, jit_compiles)
    (ExampleModel,
     lambda: ([], {}),
     lambda: ([torch.rand([4, 4, 4, 4])], {}),
     False),
]

class Test_open_mmlab_mmselfsup(_paritybench_base):
    def test_000(self):
        self._check(*TESTCASES[0])


import sys
_module = sys.modules[__name__]
del sys
draw_mpl_examples = _module
mpldrawer_examples = _module
style_examples = _module
tape_mpl_examples = _module
conf = _module
pennylane = _module
_device = _module
_grad = _module
_qubit_device = _module
_qutrit_device = _module
_version = _module
about = _module
boolean_fn = _module
circuit_graph = _module
collections = _module
apply = _module
dot = _module
map = _module
qnode_collection = _module
sum = _module
configuration = _module
data = _module
data_manager = _module
dataset = _module
debugging = _module
devices = _module
default_gaussian = _module
default_mixed = _module
default_qubit = _module
default_qubit_autograd = _module
default_qubit_jax = _module
default_qubit_tf = _module
default_qubit_torch = _module
default_qutrit = _module
null_qubit = _module
tests = _module
conftest = _module
test_compare_default_qubit = _module
test_gates = _module
test_gates_with_expval = _module
test_measurements = _module
test_properties = _module
test_tracker = _module
test_wires = _module
drawer = _module
draw = _module
drawable_layers = _module
mpldrawer = _module
style = _module
tape_mpl = _module
tape_text = _module
utils = _module
fourier = _module
circuit_spectrum = _module
coefficients = _module
qnode_spectrum = _module
reconstruct = _module
visualize = _module
gradients = _module
finite_difference = _module
general_shift_rules = _module
gradient_transform = _module
hamiltonian_grad = _module
hessian_transform = _module
jvp = _module
parameter_shift = _module
parameter_shift_cv = _module
parameter_shift_hessian = _module
spsa_gradient = _module
vjp = _module
grouping = _module
graph_colouring = _module
group_observables = _module
optimize_measurements = _module
pauli = _module
transformations = _module
interfaces = _module
autograd = _module
execution = _module
jax = _module
jax_jit = _module
jax_jit_tuple = _module
set_shots = _module
tensorflow = _module
tensorflow_autograph = _module
io = _module
kernels = _module
cost_functions = _module
postprocessing = _module
math = _module
is_independent = _module
matrix_manipulation = _module
multi_dispatch = _module
quantum = _module
single_dispatch = _module
utils = _module
measurements = _module
classical_shadow = _module
counts = _module
expval = _module
mid_measure = _module
mutual_info = _module
probs = _module
purity = _module
sample = _module
state = _module
var = _module
vn_entropy = _module
numpy = _module
fft = _module
linalg = _module
random = _module
tensor = _module
wrapper = _module
operation = _module
ops = _module
channel = _module
cv = _module
functions = _module
eigvals = _module
equal = _module
generator = _module
is_commuting = _module
is_hermitian = _module
is_unitary = _module
map_wires = _module
matrix = _module
simplify = _module
identity = _module
op_math = _module
adjoint_class = _module
adjoint_constructor = _module
composite = _module
control = _module
controlled_class = _module
exp = _module
pow = _module
prod = _module
sprod = _module
symbolicop = _module
qubit = _module
arithmetic_ops = _module
attributes = _module
hamiltonian = _module
matrix_ops = _module
non_parametric_ops = _module
observables = _module
parametric_ops = _module
qchem_ops = _module
state_preparation = _module
qutrit = _module
snapshot = _module
optimize = _module
adagrad = _module
adam = _module
adaptive = _module
gradient_descent = _module
lie_algebra = _module
momentum = _module
nesterov_momentum = _module
qng = _module
qnspsa = _module
rms_prop = _module
rotoselect = _module
rotosolve = _module
shot_adaptive = _module
spsa = _module
conversion = _module
pauli_arithmetic = _module
qaoa = _module
cost = _module
cycle = _module
layers = _module
mixers = _module
qchem = _module
basis_data = _module
basis_set = _module
convert = _module
dipole = _module
factorization = _module
hartree_fock = _module
integrals = _module
matrices = _module
molecule = _module
number = _module
observable_hf = _module
openfermion_obs = _module
spin = _module
structure = _module
tapering = _module
qinfo = _module
transforms = _module
qnn = _module
cost = _module
keras = _module
qnode = _module
queuing = _module
resource = _module
first_quantization = _module
measurement = _module
second_quantization = _module
return_types = _module
shadows = _module
tape = _module
operation_recorder = _module
qscript = _module
unwrap = _module
templates = _module
broadcast = _module
embeddings = _module
amplitude = _module
angle = _module
basis = _module
displacement = _module
iqp = _module
qaoaembedding = _module
squeezing = _module
layer = _module
basic_entangler = _module
cv_neural_net = _module
gate_fabric = _module
particle_conserving_u1 = _module
particle_conserving_u2 = _module
random = _module
simplified_two_design = _module
strongly_entangling = _module
state_preparations = _module
arbitrary_state_preparation = _module
mottonen = _module
subroutines = _module
all_singles_doubles = _module
approx_time_evolution = _module
arbitrary_unitary = _module
commuting_evolution = _module
fermionic_double_excitation = _module
fermionic_single_excitation = _module
flip_sign = _module
grover = _module
hilbert_schmidt = _module
interferometer = _module
kupccgsd = _module
permute = _module
qft = _module
qmc = _module
qpe = _module
uccsd = _module
swapnetworks = _module
ccl2 = _module
tensornetworks = _module
mera = _module
mps = _module
ttn = _module
tracker = _module
adjoint_metric_tensor = _module
batch_input = _module
batch_params = _module
batch_partial = _module
batch_transform = _module
broadcast_expand = _module
classical_jacobian = _module
commutation_dag = _module
compile = _module
condition = _module
decompositions = _module
single_qubit_unitary = _module
two_qubit_unitary = _module
defer_measurements = _module
hamiltonian_expand = _module
insert_ops = _module
measurement_grouping = _module
metric_tensor = _module
mitigate = _module
op_transforms = _module
optimization = _module
cancel_inverses = _module
commute_controlled = _module
merge_amplitude_embedding = _module
merge_rotations = _module
optimization_utils = _module
pattern_matching = _module
remove_barrier = _module
single_qubit_fusion = _module
undo_swaps = _module
qcut = _module
cutcircuit = _module
cutstrategy = _module
kahypar = _module
montecarlo = _module
processing = _module
tapes = _module
qfunc_transforms = _module
specs = _module
split_non_commuting = _module
tape_expand = _module
transpile = _module
unitary_to_rot = _module
zx = _module
converter = _module
vqe = _module
vqe = _module
wires = _module
setup = _module
test_circuit_graph = _module
test_circuit_graph_hash = _module
test_qasm = _module
test_collections = _module
test_qnode_collection = _module
conftest = _module
test_dataset = _module
test_dataset_access = _module
test_default_gaussian = _module
test_default_mixed = _module
test_default_mixed_autograd = _module
test_default_mixed_jax = _module
test_default_mixed_tf = _module
test_default_mixed_torch = _module
test_default_qubit = _module
test_default_qubit_autograd = _module
test_default_qubit_broadcasting = _module
test_default_qubit_jax = _module
test_default_qubit_tf = _module
test_default_qubit_torch = _module
test_default_qutrit = _module
test_lightning_qubit = _module
test_null_qubit = _module
test_supported_confs = _module
test_draw = _module
test_draw_mpl = _module
test_drawable_layers = _module
test_drawer_utils = _module
test_mpldrawer = _module
test_style = _module
test_tape_mpl = _module
test_tape_text = _module
test_circuit_spectrum = _module
test_coefficients = _module
test_fourier_utils = _module
test_qnode_spectrum = _module
test_reconstruct = _module
test_visualize = _module
gate_data = _module
test_gpu_torch = _module
test_finite_difference = _module
test_general_shift_rules = _module
test_gradient_transform = _module
test_hamiltonian_gradient = _module
test_parameter_shift = _module
test_parameter_shift_cv = _module
test_parameter_shift_hessian = _module
test_spsa_gradient = _module
test_vjp = _module
test_graph_colouring = _module
test_group_observables = _module
test_grouping_utils = _module
test_optimize_measurements = _module
test_pauli_group = _module
test_autograd = _module
test_autograd_qnode = _module
test_jax = _module
test_jax_qnode = _module
test_tensorflow = _module
test_tensorflow_qnode = _module
test_torch = _module
test_torch_qnode = _module
test_kernels = _module
test_basic_math = _module
test_density_matrices = _module
test_entropies_math = _module
test_fidelity_math = _module
test_functions = _module
test_is_abstract = _module
test_is_independent = _module
test_matrix_manipulation = _module
test_multi_dispatch = _module
test_classical_shadow = _module
test_counts = _module
test_expval = _module
test_mid_measure = _module
test_mutual_info = _module
test_probs = _module
test_purity_measurement = _module
test_sample = _module
test_state = _module
test_var = _module
test_vn_entropy = _module
test_numpy_random = _module
test_numpy_wrapper = _module
test_pickling = _module
test_eigvals = _module
test_equal = _module
test_generator = _module
test_is_commuting = _module
test_is_hermitian = _module
test_is_unitary = _module
test_map_wires = _module
test_matrix = _module
test_simplify = _module
test_adjoint_op = _module
test_adjoint_transform = _module
test_composite = _module
test_control = _module
test_controlled_op = _module
test_exp = _module
test_pow_op = _module
test_prod = _module
test_sprod = _module
test_sum = _module
test_symbolic_op = _module
test_all_qubit_ops = _module
test_arithmetic_ops = _module
test_attributes = _module
test_hamiltonian = _module
test_matrix_ops = _module
test_non_parametric_ops = _module
test_observables = _module
test_parametric_ops = _module
test_qchem_ops = _module
test_sparse = _module
test_state_prep = _module
test_qutrit_matrix_ops = _module
test_qutrit_non_parametric_ops = _module
test_qutrit_observables = _module
test_channel_ops = _module
test_cv_ops = _module
test_identity = _module
test_snapshot = _module
test_adagrad = _module
test_adam = _module
test_adaptive = _module
test_gradient_descent = _module
test_lie_algebra = _module
test_momentum = _module
test_nesterov_momentum = _module
test_optimize = _module
test_optimize_shot_adaptive = _module
test_qng = _module
test_qnspsa = _module
test_rmsprop = _module
test_rotoselect = _module
test_rotosolve = _module
test_spsa = _module
test_pauli_graph_colouring = _module
test_pauli_group_observables = _module
test_pauli_optimize_measurements = _module
test_conversion = _module
test_pauli_arithmetic = _module
test_pauli_utils = _module
test_convert = _module
test_decompose = _module
test_dipole_of = _module
test_meanfield = _module
test_molecular_hamiltonian = _module
test_observable_of = _module
test_one_particle = _module
test_two_particle = _module
test_basis_set = _module
test_dipole = _module
test_factorization = _module
test_hamiltonians = _module
test_hartree_fock = _module
test_integrals = _module
test_matrices = _module
test_molecule = _module
test_observable_hf = _module
test_particle_number = _module
test_spin = _module
test_structure = _module
test_tapering = _module
test_entropies = _module
test_fidelity = _module
test_fisher = _module
test_purity = _module
test_reduced_dm = _module
test_cost = _module
test_keras = _module
test_qnn_torch = _module
test_first_quantization = _module
test_measurement = _module
test_second_quantization = _module
test_autograd_new = _module
test_autograd_qnode_new = _module
test_autograd_qnode_shot_vector = _module
test_new_qscript = _module
test_new_return_types = _module
test_new_return_types_qnode = _module
test_finite_difference_new = _module
test_finite_difference_shot_vec_new = _module
test_adjoint_diff_new = _module
test_jvp = _module
test_spsa_gradient_new = _module
test_spsa_gradient_shot_vec_new = _module
test_vjp_new = _module
test_jax_jit_new = _module
test_jax_jit_qnode_new = _module
test_jax_new = _module
test_jax_qnode_new = _module
test_jax_qnode_shot_vector = _module
test_new_lie_algebra_optimizer = _module
test_new_qnspsa = _module
test_parameter_shift_hessian_new = _module
test_parameter_shift_new = _module
test_parameter_shift_shot_vec_new = _module
test_tensorflow_autograph_qnode_shot_vector = _module
test_tensorflow_new = _module
test_tensorflow_qnode_new = _module
test_tensorflow_qnode_shot_vector = _module
test_torch_new = _module
test_torch_qnode_new = _module
test_adjoint_metric_tensor_new = _module
test_batch_input_new = _module
test_batch_params_new = _module
test_fisher_new = _module
test_metric_tensor_new = _module
test_mitigate_new = _module
test_qcut_new = _module
test_shadow_transforms_new = _module
test_split_non_commuting_new = _module
test_shadow_class = _module
test_shadow_entropies = _module
test_transforms = _module
test_operation_recorder = _module
test_qscript = _module
test_tape = _module
test_unwrap = _module
test_broadcast = _module
test_amplitude = _module
test_angle = _module
test_basis = _module
test_displacement_emb = _module
test_iqp_emb = _module
test_qaoa_emb = _module
test_squeezing_emb = _module
test_layer = _module
test_basic_entangler = _module
test_cv_neural_net = _module
test_gate_fabric = _module
test_particle_conserving_u1 = _module
test_particle_conserving_u2 = _module
test_random = _module
test_simplified_twodesign = _module
test_strongly_entangling = _module
test_arbitrary_state_prep = _module
test_basis_state_prep = _module
test_mottonen_state_prep = _module
test_all_singles_doubles = _module
test_approx_time_evolution = _module
test_arbitrary_unitary = _module
test_commuting_evolution = _module
test_double_excitation = _module
test_flip_sign = _module
test_grover = _module
test_hilbert_schmidt = _module
test_interferometer = _module
test_kupccgsd = _module
test_permute = _module
test_qft = _module
test_qmc = _module
test_qpe = _module
test_single_excitation = _module
test_uccsd = _module
test_ccl2 = _module
test_MERA = _module
test_MPS = _module
test_TTN = _module
test_about = _module
test_boolean_fn = _module
test_classical_gradients = _module
test_configuration = _module
test_debugging = _module
test_device = _module
test_hermitian_edge_cases = _module
test_io = _module
test_measurement_transformations = _module
test_observable = _module
test_operation = _module
test_qaoa = _module
test_qnode = _module
test_quantum_gradients = _module
test_qubit_device = _module
test_qubit_device_adjoint_jacobian = _module
test_queuing = _module
test_qutrit_device = _module
test_tensor_measurements = _module
test_utils = _module
test_vqe = _module
test_adjoint_metric_tensor = _module
test_batch_input = _module
test_batch_params = _module
test_batch_partial = _module
test_batch_transform = _module
test_broadcast_expand = _module
test_classical_jacobian = _module
test_commutation_dag = _module
test_compile = _module
test_condition = _module
test_decompositions = _module
test_defer_measurements = _module
test_hamiltonian_expand = _module
test_insert_ops = _module
test_measurement_grouping = _module
test_metric_tensor = _module
test_mitigate = _module
test_op_transform = _module
test_cancel_inverses = _module
test_commute_controlled = _module
test_merge_amplitude_embedding = _module
test_merge_rotations = _module
test_optimization_utils = _module
test_pattern_matching = _module
test_single_qubit_fusion = _module
test_undo_swaps = _module
test_qcut = _module
test_qfunc_transform = _module
test_qmc_transform = _module
test_specs = _module
test_split_non_commuting = _module
test_tape_expand = _module
test_transpile = _module
test_unitary_to_rot = _module
test_zx = _module

from _paritybench_helpers import _mock_config, patch_functional
from unittest.mock import mock_open, MagicMock
from torch.autograd import Function
from torch.nn import Module
import abc, collections, copy, enum, functools, inspect, itertools, logging, math, matplotlib, numbers, numpy, pandas, queue, random, re, scipy, sklearn, string, tensorflow, time, torch, torchaudio, torchtext, torchvision, types, typing, uuid, warnings
import numpy as np
from torch import Tensor
patch_functional()
open = mock_open()
yaml = logging = sys = argparse = MagicMock()
ArgumentParser = argparse.ArgumentParser
_global_config = args = argv = cfg = config = params = _mock_config()
argparse.ArgumentParser.return_value.parse_args.return_value = _global_config
yaml.load.return_value = _global_config
sys.argv = _global_config
__version__ = '1.0.0'
xrange = range
wraps = functools.wraps


from collections.abc import Sequence


import warnings


import functools


import itertools


from string import ascii_letters as ABC


import numpy as np


from scipy.sparse import csr_matrix


from collections import defaultdict


from functools import partial


import inspect


from functools import wraps


from typing import Callable


from typing import Sequence


import torch


import torch.utils._pytree as pytree


from functools import reduce


from typing import Generator


from typing import Iterable


from typing import Tuple


from scipy.sparse import eye


from scipy.sparse import kron


import numpy as onp


from numpy import ndarray


from numpy import float64


import numbers


from scipy.linalg import block_diag as _scipy_block_diag


import numpy as _np


import scipy


from functools import singledispatch


from typing import Union


from copy import copy


from warnings import warn


from scipy.sparse.linalg import expm as sparse_expm


from collections.abc import Iterable


from typing import List


import math


from typing import Dict


from typing import Any


from itertools import combinations


import re


from itertools import product


from collections import OrderedDict


from inspect import signature


from itertools import chain


import numpy as vanilla_numpy


from torch.autograd.functional import hessian


from torch.autograd.functional import jacobian


import scipy as s


import copy


from scipy import sparse


from scipy.stats import unitary_group


from scipy.linalg import expm


from scipy.linalg import fractional_matrix_power


import numpy


from scipy.linalg import block_diag


import string


from numpy.linalg import multi_dot


class MeasurementShapeError(ValueError):
    """An error raised when an unsupported operation is attempted with a
    quantum tape."""


class OperatorPropertyUndefined(Exception):
    """Generic exception to be used for undefined
    Operator properties or methods."""


class GeneratorUndefinedError(OperatorPropertyUndefined):
    """Exception used to indicate that an operator
    does not have a generator"""


class AdjointUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's adjoint version is undefined."""


class DecompositionUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's representation as a decomposition is undefined."""


class DiagGatesUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's diagonalizing gates are undefined."""


class EigvalsUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's eigenvalues are undefined."""


class MatrixUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's matrix representation is undefined."""


class PowUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's power is undefined."""


class SparseMatrixUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's sparse matrix representation is undefined."""


class TermsUndefinedError(OperatorPropertyUndefined):
    """Raised when an Operator's representation as a linear combination is undefined."""


class WireError(Exception):
    """Exception raised by a :class:`~.pennylane.wires.Wire` object when it is unable to process wires."""


def _process(wires):
    """Converts the input to a tuple of wire labels.

    If `wires` can be iterated over, its elements are interpreted as wire labels
    and turned into a tuple. Otherwise, `wires` is interpreted as a single wire label.

    The only exception to this are strings, which are always interpreted as a single
    wire label, so users can address wires with labels such as `"ancilla"`.

    Any type can be a wire label, as long as it is hashable. We need this to establish
    the uniqueness of two labels. For example, `0` and `0.` are interpreted as
    the same wire label because `hash(0.) == hash(0)` evaluates to true.

    Note that opposed to numpy arrays, `pennylane.numpy` 0-dim array are hashable.
    """
    if isinstance(wires, str):
        wires = [wires]
    try:
        tuple_of_wires = tuple(wires)
    except TypeError:
        try:
            hash(wires)
        except TypeError as e:
            if str(e).startswith('unhashable'):
                raise WireError(f'Wires must be hashable; got object of type {type(wires)}.') from e
        return wires,
    try:
        set_of_wires = set(wires)
    except TypeError as e:
        if str(e).startswith('unhashable'):
            raise WireError(f'Wires must be hashable; got {wires}.') from e
    if len(set_of_wires) != len(tuple_of_wires):
        raise WireError(f'Wires must be unique; got {wires}.')
    return tuple_of_wires


class Wires(Sequence):
    """
    A bookkeeping class for wires, which are ordered collections of unique objects.

    If the input `wires` can be iterated over, it is interpreted as a sequence of wire labels that have to be
    unique and hashable. Else it is interpreted as a single wire label that has to be hashable. The
    only exception are strings which are interpreted as wire labels.

    The hash function of a wire label is considered the source of truth when deciding whether
    two wire labels are the same or not.

    Indexing an instance of this class will return a wire label.

    Args:
         wires (Any): the wire label(s)
    """

    def __init__(self, wires, _override=False):
        if _override:
            self._labels = wires
        else:
            self._labels = _process(wires)
        self._hash = None

    def __getitem__(self, idx):
        """Method to support indexing. Returns a Wires object if index is a slice,
        or a label if index is an integer."""
        if isinstance(idx, slice):
            return Wires(self._labels[idx])
        return self._labels[idx]

    def __iter__(self):
        return self._labels.__iter__()

    def __len__(self):
        """Method to support ``len()``."""
        return len(self._labels)

    def contains_wires(self, wires):
        """Method to determine if Wires object contains wires in another Wires object."""
        if isinstance(wires, Wires):
            return set(wires.labels).issubset(set(self._labels))
        return False

    def __contains__(self, item):
        """Method checking if Wires object contains an object."""
        return item in self._labels

    def __repr__(self):
        """Method defining the string representation of this class."""
        return f'<Wires = {list(self._labels)}>'

    def __eq__(self, other):
        """Method to support the '==' operator.
        This will also implicitly define the '!=' operator."""
        if isinstance(other, Wires):
            return self._labels == other.labels
        return self._labels == other

    def __hash__(self):
        """Implements the hash function."""
        if self._hash is None:
            self._hash = hash(self._labels)
        return self._hash

    def __add__(self, other):
        """Defines the addition to return a Wires object containing all wires of the two terms.

        Args:
            other (Iterable[Number,str], Number, Wires): object to add from the right

        Returns:
            Wires: all wires appearing in either object

        **Example**

        >>> wires1 =  Wires([4, 0, 1])
        >>> wires2 = Wires([1, 2])
        >>> wires1 + wires2
        Wires([4, 0, 1, 2])
        """
        other = Wires(other)
        return Wires.all_wires([self, other])

    def __radd__(self, other):
        """Defines addition according to __add__ if the left object has no addition defined.

        Args:
            other (Iterable[Number,str], Number, Wires): object to add from the left

        Returns:
            Wires: all wires appearing in either object
        """
        other = Wires(other)
        return Wires.all_wires([other, self])

    def __array__(self):
        """Defines a numpy array representation of the Wires object.

        Returns:
            ndarray: array representing Wires object
        """
        return np.array(self._labels)

    @property
    def labels(self):
        """Get a tuple of the labels of this Wires object."""
        return self._labels

    def toarray(self):
        """Returns a numpy array representation of the Wires object.

        Returns:
            ndarray: array representing Wires object
        """
        return np.array(self._labels)

    def tolist(self):
        """Returns a list representation of the Wires object.

        Returns:
            List: list of wire labels
        """
        return list(self._labels)

    def toset(self):
        """Returns a set representation of the Wires object.

        Returns:
            Set: set of wire labels
        """
        return set(self.labels)

    def index(self, wire):
        """Overwrites a Sequence's ``index()`` function which returns the index of ``wire``.

        Args:
            wire (Any): Object whose index is to be found. If this is a Wires object of length 1, look for the object
                representing the wire.

        Returns:
            int: index of the input
        """
        if isinstance(wire, Wires):
            if len(wire) != 1:
                raise WireError('Can only retrieve index of a Wires object of length 1.')
            wire = wire[0]
        try:
            return self._labels.index(wire)
        except ValueError as e:
            raise WireError(f'Wire with label {wire} not found in {self}.') from e

    def indices(self, wires):
        """
        Return the indices of the wires in this Wires object.

        Args:
            wires (Iterable[Number, str], Number, str, Wires): Wire(s) whose indices are to be found

        Returns:
            List: index list

        **Example**

        >>> wires1 =  Wires([4, 0, 1])
        >>> wires2 = Wires([1, 4])
        >>> wires1.indices(wires2)
        [2, 0]
        >>> wires1.indices([1, 4])
        [2, 0]
        """
        if not isinstance(wires, Iterable):
            return [self.index(wires)]
        return [self.index(w) for w in wires]

    def map(self, wire_map):
        """Returns a new Wires object with different labels, using the rule defined in mapping.

        Args:
            wire_map (dict): Dictionary containing all wire labels used in this object as keys, and unique
                             new labels as their values
        **Example**

        >>> wires = Wires(['a', 'b', 'c'])
        >>> wire_map = {'a': 4, 'b':2, 'c': 3}
        >>> wires.map(wire_map)
        <Wires = [4, 2, 3]>
        """
        for w in self:
            if w not in wire_map:
                raise WireError(f'No mapping for wire label {w} specified in wire map {wire_map}.')
        new_wires = [wire_map[w] for w in self]
        try:
            new_wires = Wires(new_wires)
        except WireError as e:
            raise WireError(f'Failed to implement wire map {wire_map}. Make sure that the new labels are unique and valid wire labels.') from e
        return new_wires

    def subset(self, indices, periodic_boundary=False):
        """
        Returns a new Wires object which is a subset of this Wires object. The wires of the new
        object are the wires at positions specified by 'indices'. Also accepts a single index as input.

        Args:
            indices (List[int] or int): indices or index of the wires we want to select
            periodic_boundary (bool): controls periodic boundary conditions in the indexing

        Returns:
            Wires: subset of wires

        **Example**

        >>> wires = Wires([4, 0, 1, 5, 6])
        >>> wires.subset([2, 3, 0])
        <Wires = [1, 5, 4]>
        >>> wires.subset(1)
        <Wires = [0]>

        If ``periodic_boundary`` is True, the modulo of the number of wires of an index is used instead of an index,
        so that  ``wires.subset(i) == wires.subset(i % n_wires)`` where ``n_wires`` is the number of wires of this
        object.

        >>> wires = Wires([4, 0, 1, 5, 6])
        >>> wires.subset([5, 1, 7], periodic_boundary=True)
        <Wires = [4, 0, 1]>

        """
        if isinstance(indices, int):
            indices = [indices]
        if periodic_boundary:
            indices = [(i % len(self._labels)) for i in indices]
        for i in indices:
            if i > len(self._labels):
                raise WireError(f'Cannot subset wire at index {i} from {len(self._labels)} wires.')
        subset = tuple(self._labels[i] for i in indices)
        return Wires(subset, _override=True)

    def select_random(self, n_samples, seed=None):
        """
        Returns a randomly sampled subset of Wires of length 'n_samples'.

        Args:
            n_samples (int): number of subsampled wires
            seed (int): optional random seed used for selecting the wires

        Returns:
            Wires: random subset of wires
        """
        if n_samples > len(self._labels):
            raise WireError(f'Cannot sample {n_samples} wires from {len(self._labels)} wires.')
        if seed is not None:
            np.random.seed(seed)
        indices = np.random.choice(len(self._labels), size=n_samples, replace=False)
        subset = tuple(self[i] for i in indices)
        return Wires(subset, _override=True)

    @staticmethod
    def shared_wires(list_of_wires):
        """Return only the wires that appear in each Wires object in the list.

        This is similar to a set intersection method, but keeps the order of wires as they appear in the list.

        Args:
            list_of_wires (List[Wires]): list of Wires objects

        Returns:
            Wires: shared wires

        **Example**

        >>> wires1 =  Wires([4, 0, 1])
        >>> wires2 = Wires([3, 0, 4])
        >>> wires3 = Wires([4, 0])
        >>> Wires.shared_wires([wires1, wires2, wires3])
        <Wires = [4, 0]>
        >>> Wires.shared_wires([wires2, wires1, wires3])
        <Wires = [0, 4]>
        """
        for wires in list_of_wires:
            if not isinstance(wires, Wires):
                raise WireError(f'Expected a Wires object; got {wires} of type {type(wires)}.')
        sets_of_wires = [wire.toset() for wire in list_of_wires]
        intersecting_wires = functools.reduce(lambda a, b: a & b, sets_of_wires)
        shared = []
        for wire in list_of_wires[0]:
            if wire in intersecting_wires:
                shared.append(wire)
        return Wires(tuple(shared), _override=True)

    @staticmethod
    def all_wires(list_of_wires, sort=False):
        """Return the wires that appear in any of the Wires objects in the list.

        This is similar to a set combine method, but keeps the order of wires as they appear in the list.

        Args:
            list_of_wires (List[Wires]): List of Wires objects
            sort (bool): Toggle for sorting the combined wire labels. The sorting is based on
                value if all keys are int, else labels' str representations are used.

        Returns:
            Wires: combined wires

        **Example**

        >>> wires1 = Wires([4, 0, 1])
        >>> wires2 = Wires([3, 0, 4])
        >>> wires3 = Wires([5, 3])
        >>> list_of_wires = [wires1, wires2, wires3]
        >>> Wires.all_wires(list_of_wires)
        <Wires = [4, 0, 1, 3, 5]>
        """
        converted_wires = (wires if isinstance(wires, Wires) else Wires(wires) for wires in list_of_wires)
        all_wires_list = itertools.chain(*(w.labels for w in converted_wires))
        combined = list(dict.fromkeys(all_wires_list))
        if sort:
            if all(isinstance(w, int) for w in combined):
                combined = sorted(combined)
            else:
                combined = sorted(combined, key=str)
        return Wires(tuple(combined), _override=True)

    @staticmethod
    def unique_wires(list_of_wires):
        """Return the wires that are unique to any Wire object in the list.

        Args:
            list_of_wires (List[Wires]): list of Wires objects

        Returns:
            Wires: unique wires

        **Example**

        >>> wires1 = Wires([4, 0, 1])
        >>> wires2 = Wires([0, 2, 3])
        >>> wires3 = Wires([5, 3])
        >>> Wires.unique_wires([wires1, wires2, wires3])
        <Wires = [4, 1, 2, 5]>
        """
        for wires in list_of_wires:
            if not isinstance(wires, Wires):
                raise WireError(f'Expected a Wires object; got {wires} of type {type(wires)}.')
        label_sets = [wire.toset() for wire in list_of_wires]
        seen_ever = set()
        seen_once = set()
        for labels in label_sets:
            seen_once = (seen_once ^ labels) - (seen_ever - seen_once)
            seen_ever.update(labels)
        unique = []
        for wires in list_of_wires:
            for wire in wires.tolist():
                if wire in seen_once:
                    unique.append(wire)
        return Wires(tuple(unique), _override=True)


def _process_data(op):
    if op.name in ('RX', 'RY', 'RZ', 'PhaseShift', 'Rot'):
        return str([qml.math.round(qml.math.real(d) % (2 * np.pi), 10) for d in op.data])
    if op.name in ('CRX', 'CRY', 'CRZ', 'CRot'):
        return str([qml.math.round(qml.math.real(d) % (4 * np.pi), 10) for d in op.data])
    return str(op.data)


class ClassPropertyDescriptor:
    """Allows a class property to be defined"""

    def __init__(self, fget, fset=None):
        self.fget = fget
        self.fset = fset

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        return self.fget.__get__(obj, klass)()

    def __set__(self, obj, value):
        if not self.fset:
            raise AttributeError("can't set attribute")
        type_ = type(obj)
        return self.fset.__get__(obj, type_)(value)

    def setter(self, func):
        """Set the function as a class method, and store as an attribute."""
        if not isinstance(func, (classmethod, staticmethod)):
            func = classmethod(func)
        self.fset = func
        return self


def classproperty(func):
    """The class property decorator"""
    if not isinstance(func, (classmethod, staticmethod)):
        func = classmethod(func)
    return ClassPropertyDescriptor(func)


def _permute_dense_matrix(matrix, wires, wire_order, batch_dim):
    """Permute the matrix to match the wires given in `wire_order`.

    Args:
        matrix (np.ndarray): matrix to permute
        wires (list): wires determining the subspace that base matrix acts on; a base matrix of
            dimension :math:`2^n` acts on a subspace of :math:`n` wires
        wire_order (list): global wire order, which has to contain all wire labels in ``wires``,
            but can also contain additional labels
        batch_dim (int or None): Batch dimension. If ``None``, batching is ignored.

    Returns:
        np.ndarray: permuted matrix
    """
    if wires == wire_order:
        return matrix
    perm = [wires.index(wire) for wire in wire_order]
    num_wires = len(wire_order)
    perm += [(p + num_wires) for p in perm]
    if batch_dim:
        perm = [0] + [(p + 1) for p in perm]
    shape = [batch_dim] + [2] * (num_wires * 2) if batch_dim else [2] * (num_wires * 2)
    matrix = qml.math.reshape(matrix, shape)
    matrix = qml.math.transpose(matrix, axes=perm)
    shape = [batch_dim] + [2 ** num_wires] * 2 if batch_dim else [2 ** num_wires] * 2
    return qml.math.reshape(matrix, shape)


def _sparse_swap_mat(qubit_i, qubit_j, n):
    """Helper function which generates the sparse matrix of SWAP
    for qubits: i <--> j with final shape (2**n, 2**n)."""

    def swap_qubits(index, i, j):
        s = list(format(index, f'0{n}b'))
        si, sj = s[i], s[j]
        if si == sj:
            return index
        s[i], s[j] = sj, si
        return int(f"0b{''.join(s)}", 2)
    data = [1] * 2 ** n
    index_i = list(range(2 ** n))
    index_j = [swap_qubits(idx, qubit_i, qubit_j) for idx in index_i]
    return csr_matrix((data, (index_i, index_j)))


def _permutation_sparse_matrix(expanded_wires: Iterable, wire_order: Iterable) ->csr_matrix:
    """Helper function which generates a permutation matrix in sparse format that swaps the wires
    in ``expanded_wires`` to match the order given by the ``wire_order`` argument.

    Args:
        expanded_wires (Iterable): inital wires
        wire_order (Iterable): final wires

    Returns:
        csr_matrix: permutation matrix in CSR sparse format
    """
    n_total_wires = len(wire_order)
    U = None
    for i in range(n_total_wires):
        if expanded_wires[i] != wire_order[i]:
            if U is None:
                U = eye(2 ** n_total_wires, format='csr')
            j = expanded_wires.index(wire_order[i])
            U = U @ _sparse_swap_mat(i, j, n_total_wires)
            U.eliminate_zeros()
            expanded_wires[i], expanded_wires[j] = expanded_wires[j], expanded_wires[i]
    return U


def _permute_sparse_matrix(matrix, wires, wire_order):
    """Permute the matrix to match the wires given in `wire_order`.

    Args:
        matrix (scipy.sparse.spmatrix): matrix to permute
        wires (list): wires determining the subspace that base matrix acts on; a base matrix of
            dimension :math:`2^n` acts on a subspace of :math:`n` wires
        wire_order (list): global wire order, which has to contain all wire labels in ``wires``,
            but can also contain additional labels

    Returns:
        scipy.sparse.spmatrix: permuted matrix
    """
    U = _permutation_sparse_matrix(wires, wire_order)
    if U is not None:
        matrix = U.T @ matrix @ U
        matrix.eliminate_zeros()
    return matrix


def expand_matrix(mat, wires, wire_order=None, sparse_format='csr'):
    """Re-express a matrix acting on a subspace defined by a set of wire labels
    according to a global wire order.

    Args:
        mat (tensor_like): matrix to expand
        wires (Iterable): wires determining the subspace that ``mat`` acts on; a matrix of
            dimension :math:`2^n` acts on a subspace of :math:`n` wires
        wire_order (Iterable): global wire order, which has to contain all wire labels in ``wires``, but can also
            contain additional labels
        sparse_format (str): if ``mat`` is a SciPy sparse matrix then this is the string representing the
            preferred scipy sparse matrix format to cast the expanded matrix too

    Returns:
        tensor_like: expanded matrix

    **Example**

    If the wire order is ``None`` or identical to ``wires``, the original matrix gets returned:

    >>> matrix = np.array([[1, 2, 3, 4],
    ...                         [5, 6, 7, 8],
    ...                         [9, 10, 11, 12],
    ...                         [13, 14, 15, 16]])
    >>> print(expand_matrix(matrix, wires=[0, 2], wire_order=[0, 2]))
    [[ 1  2  3  4]
     [ 5  6  7  8]
     [ 9 10 11 12]
     [13 14 15 16]]
    >>> print(expand_matrix(matrix, wires=[0, 2]))
    [[ 1  2  3  4]
     [ 5  6  7  8]
     [ 9 10 11 12]
     [13 14 15 16]]

    If the wire order is a permutation of ``wires``, the entries of the matrix get permuted:

    >>> print(expand_matrix(matrix, wires=[0, 2], wire_order=[2, 0]))
    [[ 1  3  2  4]
     [ 9 11 10 12]
     [ 5  7  6  8]
     [13 15 14 16]]

    If the wire order contains wire labels not found in ``wires``, the matrix gets expanded:

    >>> print(expand_matrix(matrix, wires=[0, 2], wire_order=[0, 1, 2]))
    [[ 1  2  0  0  3  4  0  0]
     [ 5  6  0  0  7  8  0  0]
     [ 0  0  1  2  0  0  3  4]
     [ 0  0  5  6  0  0  7  8]
     [ 9 10  0  0 11 12  0  0]
     [13 14  0  0 15 16  0  0]
     [ 0  0  9 10  0  0 11 12]
     [ 0  0 13 14  0  0 15 16]]

    The method works with tensors from all autodifferentiation frameworks, for example:

    >>> matrix_torch = torch.tensor([[1., 2.],
    ...                                   [3., 4.]], requires_grad=True)
    >>> res = expand_matrix(matrix_torch, wires=["b"], wire_order=["a", "b"])
    >>> type(res)
    torch.Tensor
    >>> res.requires_grad
    True

    The method works with scipy sparse matrices, for example:

    >>> from scipy import sparse
    >>> mat = sparse.csr_matrix([[0, 1], [1, 0]])
    >>> qml.math.expand_matrix(mat, wires=[1], wire_order=[0,1]).toarray()
    array([[0., 1., 0., 0.],
           [1., 0., 0., 0.],
           [0., 0., 0., 1.],
           [0., 0., 1., 0.]])

    """
    if wire_order is None or wire_order == wires:
        return mat
    wires = list(wires)
    wire_order = list(wire_order)
    interface = qml.math.get_interface(mat)
    shape = qml.math.shape(mat)
    batch_dim = shape[0] if len(shape) == 3 else None

    def eye_interface(dim):
        if interface == 'scipy':
            return eye(2 ** dim, format='coo')
        return qml.math.cast_like(qml.math.eye(2 ** dim, like=interface), mat)

    def kron_interface(mat1, mat2):
        if interface == 'scipy':
            res = kron(mat1, mat2, format='coo')
            res.eliminate_zeros()
            return res
        if interface == 'torch':
            mat1 = mat1.contiguous()
            mat2 = mat2.contiguous()
        return qml.math.kron(mat1, mat2, like=interface)
    wire_indices = [wire_order.index(wire) for wire in wires]
    subset_wire_order = wire_order[min(wire_indices):max(wire_indices) + 1]
    wire_difference = list(set(subset_wire_order) - set(wires))
    expanded_wires = wires + wire_difference
    if wire_difference:
        if batch_dim is not None:
            batch_matrices = [kron_interface(batch, eye_interface(len(wire_difference))) for batch in mat]
            mat = qml.math.stack(batch_matrices, like=interface)
        else:
            mat = kron_interface(mat, eye_interface(len(wire_difference)))
    if interface == 'scipy':
        mat = _permute_sparse_matrix(mat, expanded_wires, subset_wire_order)
    else:
        mat = _permute_dense_matrix(mat, expanded_wires, subset_wire_order, batch_dim)
    if len(expanded_wires) < len(wire_order):
        mats = []
        num_pre_identities = min(wire_indices)
        if num_pre_identities > 0:
            mats.append((eye_interface(num_pre_identities),))
        mats.append(tuple(mat) if batch_dim else (mat,))
        num_post_identities = len(wire_order) - max(wire_indices) - 1
        if num_post_identities > 0:
            mats.append((eye_interface(num_post_identities),))
        mats_list = list(itertools.product(*mats))
        expanded_batch_matrices = [reduce(kron_interface, mats) for mats in mats_list]
        mat = qml.math.stack(expanded_batch_matrices, like=interface) if len(expanded_batch_matrices) > 1 else expanded_batch_matrices[0]
    return mat.asformat(sparse_format) if interface == 'scipy' else mat


class ParameterFrequenciesUndefinedError(OperatorPropertyUndefined):
    """Exception used to indicate that an operator
    does not have parameter_frequencies"""


class DeviceError(Exception):
    """Exception raised by a :class:`~.pennylane._device.Device` when it encounters an illegal
    operation in the quantum circuit.
    """


def apply(func, qnode_collection):
    """Apply a function to the constituent QNodes of a :class:`QNodeCollection`.

    Args:
        func (callable): A function to be applied to the QNodeCollection results.
            This function must be supported by the corresponding QNodeCollection
            interface; i.e., a ``torch`` QNodeCollection can only be acted on functions
            that accept ``torch.tensor`` objects.
        qnode_collection (QNodeCollection): a QNode collection.

    **Example:**

    We can create a QNodeCollection using :func:`~.map`:

    >>> dev = qml.device("default.qubit", wires=2)
    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliZ(1)]
    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface="torch")

    As we are using the ``'torch'`` interface, we now apply ``torch.sum``
    to the QNodeCollection:

    >>> cost = qml.collections.apply(torch.sum, qnodes)

    This is a lazy composition --- no QNode evaluation has yet occured. Evaluation
    only occurs when the returned function ``cost`` is evaluated:

    >>> shape = qml.templates.StronglyEntanglingLayers.shape(layers=3, qubits=2)
    >>> x = np.random.random(shape)
    >>> cost(x)
    tensor(0.9092, dtype=torch.float64, grad_fn=<SumBackward0>)
    """
    new_func = lambda params, **kwargs: func(qnode_collection(params, **kwargs))
    new_func.interface = qnode_collection.interface
    return new_func


def sum(x):
    """Lazily sum the constituent QNodes of a :class:`QNodeCollection`.

    Args:
        x (QNodeCollection): a QNode collection of independent QNodes.

    .. seealso:: :func:`~.apply`, :func:`~.dot`

    **Example:**

    We can create a QNodeCollection using :func:`~.map`:

    >>> dev = qml.device("default.qubit", wires=2)
    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliZ(1)]
    >>> qnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev, interface="torch")

    For the cost function, we now sum the results of all QNodes in the collection:

    >>> cost = qml.sum(qnodes)

    This is a lazy summation --- no QNode evaluation has yet occured. Evaluation
    only occurs when the returned function ``cost`` is evaluated:

    >>> np.random.seed(42)
    >>> shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=3, n_wires=2)
    >>> x = np.random.random(shape)
    >>> cost(x)
    tensor(0.9177, dtype=torch.float64)
    """
    if hasattr(x, 'interface') and x.interface is not None:
        if x.interface == 'tf':
            import tensorflow as tf
            return apply(tf.reduce_sum, x)
        if x.interface == 'torch':
            import torch
            return apply(torch.sum, x)
        if x.interface in ('autograd', 'numpy'):
            return apply(np.sum, x)
        if x.interface == 'jax':
            return apply(jnp.sum, x)
        raise ValueError(f'Unknown interface {x.interface}')
    import numpy as np
    return apply(np.sum, x)


OBS_MAP = {'PauliX': 'X', 'PauliY': 'Y', 'PauliZ': 'Z', 'Hadamard': 'H', 'Identity': 'I'}


def _compute_grouping_indices(observables, grouping_type='qwc', method='rlf'):
    observable_groups = qml.pauli.group_observables(observables, coefficients=None, grouping_type=grouping_type, method=method)
    observables = copy(observables)
    indices = []
    available_indices = list(range(len(observables)))
    for partition in observable_groups:
        indices_this_group = []
        for pauli_word in partition:
            for observable in observables:
                if qml.pauli.are_identical_pauli_words(pauli_word, observable):
                    ind = observables.index(observable)
                    indices_this_group.append(available_indices[ind])
                    observables.pop(ind)
                    available_indices.pop(ind)
                    break
        indices.append(indices_this_group)
    return indices


def map(template, observables, device, measure='expval', interface='autograd', diff_method='best', **kwargs):
    """Map a quantum template over a list of observables to create
    a :class:`QNodeCollection`.

    The number of QNodes within the created QNode collection will match the number
    of observables passed. The device and the measurement type will either be
    applied to all QNodes in the collection, or can be provided as a list for more
    fine-grained control.

    Args:
        template (callable): the ansatz for the circuit before the final measurement step
            Note that the template **must** have the following signature:

            .. code-block:: python

                template(params, wires, **kwargs)

            where ``params`` are the trainable weights of the variational circuit,
            ``wires`` is a list of integers representing the wires of the device, and
            ``kwargs`` are any additional keyword arguments that need to be passed
            to the template.
        observables (Iterable[:class:`~.Observable`]): observables to measure during the
            final step of each circuit
        device (Device, Sequence[Device]): Corresponding device(s) where the resulting
            QNodeCollection should be executed. This can either be a single device, or a list
            of devices of length ``len(observables)``.
        measure (str, Union(List[str], Tuple[str])): Measurement(s) to perform. Options include
            :func:`'expval' <pennylane.expval>`, :func:`'var' <pennylane.var>`,
            and :func:`'sample' <pennylane.sample>`.
            This can either be a single measurement type, in which case it is applied
            to all observables, or a list of measurements of length ``len(observables)``.
        interface (str, None): which interface to use for the returned QNode collection.
            This affects the types of objects that can be passed to/returned from the QNode.
            Supports all interfaces supported by the :func:`~.qnode` decorator.
        diff_method (str, None): the method of differentiation to use in the created QNodeCollection.
            Supports all differentiation methods supported by the :func:`~.qnode` decorator.

    Returns:
        QNodeCollection: a collection of QNodes executing the circuit template with
        the specified measurements

    **Example:**

    Let's define a custom two-wire template:

    .. code-block:: python

        def my_template(params, wires, **kwargs):
            qml.RX(params[0], wires=wires[0])
            qml.RX(params[1], wires=wires[1])
            qml.CNOT(wires=wires)

    We want to compute the expectation values over the following list
    of two-qubit observables:

    >>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliX(1)]

    This can be easily done with the ``map`` function:

    >>> dev = qml.device("default.qubit", wires=2)
    >>> qnodes = qml.map(my_template, obs_list, dev, measure="expval")

    The returned :class:`~.QNodeCollection` can be evaluated, returning the results from each
    mapped QNode as an array:

    >>> params = [0.54, 0.12]
    >>> qnodes(params)
    array([-0.06154835  0.99280864])
    """
    if not callable(template):
        raise ValueError('Could not create QNodes. The template is not a callable function.')
    qnodes = QNodeCollection()
    if not isinstance(device, Sequence):
        device = [device] * len(observables)
    if not isinstance(measure, (list, tuple)):
        measure = [measure] * len(observables)
    for obs, m, dev in zip(observables, measure, device):
        if not isinstance(obs, Observable):
            raise ValueError('Could not create QNodes. Some or all observables are not valid.')
        wires = dev.wires.tolist()

        def circuit(params, _obs=obs, _m=m, _wires=wires, **circuit_kwargs):
            template(params, wires=_wires, **circuit_kwargs)
            return MEASURE_MAP[_m](_obs)
        qnode = qml.QNode(circuit, dev, interface=interface, diff_method=diff_method, **kwargs)
        qnodes.append(qnode)
    return qnodes


OPENQASM_GATES = {'CNOT': 'cx', 'CZ': 'cz', 'U3': 'u3', 'U2': 'u2', 'U1': 'u1', 'Identity': 'id', 'PauliX': 'x', 'PauliY': 'y', 'PauliZ': 'z', 'Hadamard': 'h', 'S': 's', 'S.inv': 'sdg', 'T': 't', 'T.inv': 'tdg', 'RX': 'rx', 'RY': 'ry', 'RZ': 'rz', 'CRX': 'crx', 'CRY': 'cry', 'CRZ': 'crz', 'SWAP': 'swap', 'Toffoli': 'ccx', 'CSWAP': 'cswap', 'PhaseShift': 'u1'}


class QueuingError(Exception):
    """Exception that is raised when there is a queuing error"""


class AnnotatedQueue(OrderedDict):
    """Lightweight class that maintains a basic queue of operations, in addition
    to metadata annotations."""

    def __enter__(self):
        """Adds this instance to the global list of active contexts.

        Returns:
            AnnotatedQueue: this instance
        """
        QueuingManager.add_active_queue(self)
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        """Remove this instance from the global list of active contexts."""
        QueuingManager.remove_active_queue()

    def append(self, obj, **kwargs):
        """Append ``obj`` into the queue with ``kwargs`` metadata."""
        self[obj] = kwargs

    def remove(self, obj):
        """Remove ``obj`` from the queue.  Raises ``KeyError`` if ``obj`` is not already in the queue."""
        del self[obj]

    def update_info(self, obj, **kwargs):
        """Update ``obj``'s metadata with ``kwargs`` if it exists in the queue."""
        if obj in self:
            self[obj].update(kwargs)

    def get_info(self, obj):
        """Retrieve the metadata for ``obj``.  Raises a ``QueuingError`` if obj is not in the queue."""
        if obj not in self:
            raise QueuingError(f'Object {obj} not in the queue.')
        return self[obj]

    @property
    def queue(self):
        """Returns a list of objects in the annotated queue"""
        return list(self.keys())


def process_queue(queue: AnnotatedQueue):
    """Process the annotated queue, creating a list of quantum
    operations and measurement processes.

    Args:
        queue (.AnnotatedQueue): The queue to be processed into individual lists

    Returns:
        tuple[list(.Operation), list(.MeasurementProcess)], list(.Operation):
        The list of main tape operations, the list of tape measurements, and the list of preparation operations
    """
    lists = {'_prep': [], '_ops': [], '_measurements': []}
    list_order = {'_prep': 0, '_ops': 1, '_measurements': 2}
    current_list = '_prep'
    for obj, info in queue.items():
        if 'owner' not in info and getattr(obj, '_queue_category', None) is not None:
            if list_order[obj._queue_category] > list_order[current_list]:
                current_list = obj._queue_category
            elif list_order[obj._queue_category] < list_order[current_list]:
                raise ValueError(f'{obj._queue_category[1:]} operation {obj} must occur prior to {current_list[1:]}. Please place earlier in the queue.')
            lists[obj._queue_category].append(obj)
    return lists['_ops'], lists['_measurements'], lists['_prep']


def _process_shot_sequence(shot_list):
    """Process the shot sequence, to determine the total
    number of shots and the shot vector.

    Args:
        shot_list (Sequence[int, tuple[int]]): sequence of non-negative shot integers

    Returns:
        tuple[int, list[.ShotTuple[int]]]: A tuple containing the total number
        of shots, as well as a list of shot tuples.

    **Example**

    >>> shot_list = [3, 1, 2, 2, 2, 2, 6, 1, 1, 5, 12, 10, 10]
    >>> _process_shot_sequence(shot_list)
    (57,
     [ShotTuple(shots=3, copies=1),
      ShotTuple(shots=1, copies=1),
      ShotTuple(shots=2, copies=4),
      ShotTuple(shots=6, copies=1),
      ShotTuple(shots=1, copies=2),
      ShotTuple(shots=5, copies=1),
      ShotTuple(shots=12, copies=1),
      ShotTuple(shots=10, copies=2)])

    The total number of shots (57), and a sparse representation of the shot
    sequence is returned, where tuples indicate the number of times a shot
    integer is repeated.
    """
    if all(isinstance(s, int) for s in shot_list):
        if len(set(shot_list)) == 1:
            shot_vector = [ShotTuple(shots=shot_list[0], copies=len(shot_list))]
        else:
            split_at_repeated = np.split(shot_list, np.diff(shot_list).nonzero()[0] + 1)
            shot_vector = [ShotTuple(shots=i[0], copies=len(i)) for i in split_at_repeated]
    elif all(isinstance(s, (int, tuple)) for s in shot_list):
        shot_vector = [(ShotTuple(*i) if isinstance(i, tuple) else ShotTuple(i, 1)) for i in shot_list]
    else:
        raise ValueError(f'Unknown shot sequence format {shot_list}')
    total_shots = int(np.sum(np.prod(shot_vector, axis=1)))
    return total_shots, shot_vector


INTERFACE_MAP = {None: 'Numpy', 'auto': 'auto', 'autograd': 'autograd', 'numpy': 'autograd', 'scipy': 'numpy', 'jax': 'jax', 'jax-jit': 'jax', 'jax-python': 'jax', 'JAX': 'jax', 'torch': 'torch', 'pytorch': 'torch', 'tf': 'tf', 'tensorflow': 'tf', 'tensorflow-autograph': 'tf', 'tf-autograph': 'tf'}


SUPPORTED_INTERFACES = list(INTERFACE_MAP)


def make_qscript(fn):
    """Returns a function that generates a qscript from a quantum function without any
    operation queuing taking place.

    This is useful when you would like to manipulate or transform
    the qscript created by a quantum function without evaluating it.

    Args:
        fn (function): the quantum function to generate the qscript from

    Returns:
        function: The returned function takes the same arguments as the quantum
        function. When called, it returns the generated quantum script
        without any queueing occuring.

    **Example**

    Consider the following quantum function:

    .. code-block:: python

        def qfunc(x):
            qml.Hadamard(wires=0)
            qml.CNOT(wires=[0, 1])
            qml.RX(x, wires=0)

    We can use ``make_qscript`` to extract the qscript generated by this
    quantum function, without any of the operations being queued by
    any existing queuing contexts:

    >>> with qml.queuing.AnnotatedQueue() as active_queue:
    ...     _ = qml.RY(1.0, wires=0)
    ...     qs = make_qscript(qfunc)(0.5)
    >>> qs.operations
    [Hadamard(wires=[0]), CNOT(wires=[0, 1]), RX(0.5, wires=[0])]

    Note that the currently recording queue did not queue any of these quantum operations:

    >>> active_queue.queue
    [RY(1.0, wires=[0])]
    """

    def wrapper(*args, **kwargs):
        with AnnotatedQueue() as q:
            result = fn(*args, **kwargs)
        qscript = QuantumScript.from_queue(q)
        qscript._qfunc_output = result
        return qscript
    return wrapper

